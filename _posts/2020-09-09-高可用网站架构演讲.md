---
layout: post
title: 高可用网站架构演讲
---

# 什么是高可用

[第二页 什么是高可用]

是指以减少服务中断时间为目的技术统称。它通过保护用户的业务程序对外不间断地提供服务，把因为软件，硬件，人为造成的故障对业务的影响降低到最小程度。总而言之就是保证公司业务7*24小时不宕机。

## 高可用的衡量标准

通常用平均无故障时间(MTTF：mean time to failure)来衡量系统的可靠性，用平均故障维修时间（MTTR：Mean Time Between Failures）来度量系统的可维护性。于是可用性被定义为： HA=MTTF/(MTTF+MTTR)*100%。

简单理解：如果系统每运行100个时间单位，会有1个时间单位无法提供服务，我们说系统的可用性是99%。

**衡量也受监测设备的局限，比如监测设备本身的故障、监测点的盲区、监测链路的网络故障等影响，不存在完美的衡量标准！**

# 如何保障系统的高可用

[第三页 如何保障高可用]

我们都知道，单点往往是系统高可用最大的风险和敌人，应该尽量在系统设计的过程中避免单点。方法论上，高可用保证的原则是“集群化”，或者叫“冗余”：只有一个单点，挂了服务肯定会受影响；如果有冗余备份，挂了还有其他backup能够顶上。

保证系统高可用，架构设计的核心准则是：冗余。

有了冗余之后，还不够，如果每次出现故障需要人工介入恢复势必会增加系统的不可服务时间。所以，又往往是通过“自动故障转移”来实现系统的高可用。

# 下面我们看看一般网站是如何做冗余的

[第四页 架构图]

**图上是一个比较大型的网站架构图，可以看到里面大量使用到了分布式集群化部署，这种分布式集群化就是一种冗余架构。但是大部分中小网站目前还是采用单点形式，事实上分布式集群并不适合所有场景。**

**下面来想想看为什么？** （为什么分布式集群并不适合所有场景？）

[第五页 为什么分布式集群不适合所有场景？ ]

**在网站初期考虑到人员、成本、项目复杂度等因素，一般会采用单点形式。**

先来通俗解释一下什么是分布式：原本需要一个人干的事，现在分给n个人干！

但问题来了，既然分给了n个人，那就涉及到这些人的沟通交流协作问题。

如何来解决这些问题，就需要先聊聊分布式系统中的CAP理论。

# CAP定理

[第六页 CAP理论 ]

我们先来了解一下这个理论产生的历史，CAP定理，也叫布鲁尔定理。

这个定理起源于加州大学柏克莱分校的计算机科学家埃里克·布鲁尔在2000年的分布式计算原理研讨会上提出的一个猜想。 在2002年，MIT麻省理工学院的赛斯·吉尔伯特 和 南希·林奇 发表了 **布鲁尔猜想** 的证明，使之成为一个定理。

事实上 吉尔伯特 和 林奇 证明的CAP定理比 布鲁尔 设想的某种程度上更加狭义。定理讨论了在两个互相矛盾的请求到达彼此连接不通的两个不同的分布式节点的时候的处理方案。

> 埃里克·布鲁尔是加州大学伯克利分校的终身教授。 1996年，布鲁尔创立了Inktomi公司（该公司开发了Traffic Server，这是一种代理服务器 Web缓存，用于万维网流量和按需流媒体，它们可以将图像转码为较小的尺寸，以供拨号Internet访问的用户使用。Traffic Server由包括AOL（American Online美国在线）在内的数家大型ISP部署。 在2003年互联网泡沫破灭之后，该公司以被2.41亿美元Yahoo!收购。）在2000年他与比尔·克林顿合作，他帮助创建USA.gov。在大约1990年代末的分布式网络应用中，他由于制定CAP定理而闻名。目前，他在谷歌任职。



## 下面我们来看看CAP定理

[第七页 CAP定理 ]

CAP定理指的是一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项。

## 一致性

[第八页 一致性]

一致性，意思是写操作之后的读操作，必须返回该值。举例来说，某条记录是 v0，用户向 G1 发起一个写操作，将其改为 v1。

接下来，用户的读操作就会得到 v1。这就叫一致性。

问题是，用户有可能向 G2 发起读操作，由于 G2 的值没有发生变化，因此返回的是 v0。G1 和 G2 读操作的结果不一致，这就不满足一致性了。

为了让 G2 也能变为 v1，就要在 G1 写操作的时候，让 G1 向 G2 发送一条消息，要求 G2 也改成 v1。

这样的话，用户向 G2 发起读操作，也能得到 v1。

## 可用性

可用性，意思是只要收到用户的请求，服务器就必须给出回应。

用户可以选择向 G1 或 G2 发起读操作。不管是哪台服务器，只要收到请求，就必须告诉用户，到底是 v0 还是 v1，否则就不满足可用性。

## 一致性和可用性的矛盾

[第九页 一致性和可用性的矛盾]

一致性和可用性，为什么不可能同时成立？答案很简单，因为可能通信失败（即出现分区容错）。

如果保证 G2 的一致性，那么 G1 必须在写操作时，锁定 G2 的读操作和写操作。只有数据同步后，才能重新开放读写。锁定期间，G2 不能读写，没有可用性不。

如果保证 G2 的可用性，那么势必不能锁定 G2，所以一致性不成立。

综上所述，G2 无法同时做到一致性和可用性。系统设计时只能选择一个目标。如果追求一致性，那么无法保证所有节点的可用性；如果追求所有节点的可用性，那就没法做到一致性。

## 一致性和可用性权衡

【讨论1】在什么场合，可用性高于一致性？

CDN，新闻资讯，静态资源，搜索引擎。。。

【讨论2】在什么场合，一致性高于可用性？

电商订单，银行系统，证券金融系统，购票系统。。。

讨论完毕，就要引出BASE理论了

## BASE理论

[第十页 BASE理论]

BASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的简写，BASE是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的结论，是基于CAP定理逐步演化而来的，其核心思想是即使无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。

- 基本可用（basically available）：在分布式系统出现，允许损失部分可用性（服务降级、页面降级）
- 软状态（soft state）：允许分布式系统出现中间状态，而且中间状态不影响系统的可用性
- 最终一致性（Eventually consistent）：数据复制经过一段时间达到一致性

分布式系统是一个非常广泛的概念，它最终要落实到解决实际问题上，不同的问题有不同的方法和架构。

但如果以算法划分，到能分出几类：

1.以Leader选举为主的分布式一致性算法，比如paxos、viewstamp，就是现在zookeeper、Chuby等工具的主体
2.以分布式事务为主的一类主要是二段提交，这些分布式数据库管理器及数据库都支持
3.以若一致性为主的，主要代表是Cassandra的W、R、N可调节的一致性
4.以租赁机制为主的，主要是一些分布式锁的概念，目前还没有看到纯粹“分布式”锁的实现
5.以失败探测为主的，主要是Gossip和phi失败探测算法，当然也包括简单的心跳
6.以弱一致性、因果一致性、顺序一致性为主的，开源尚不多，但大都应用在Linkedin、Twitter、Facebook等公司内部
7.以异步解耦为主的，有各类Queue











