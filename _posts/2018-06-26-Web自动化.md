---
layout: post
title:  "Web自动化"
---

# 自动化测试

自动化测试是软件开发过程中的一个重要环节，它有许多好处，主要有：

1.持续集成和持续部署：自动化测试是实现持续集成（CI）和持续部署（CD）的关键。在每次代码提交后，自动化测试可以立即运行，确保新的改动没有破坏现有的功能。

2.回归测试：当代码发生更改时，自动化测试可以帮助检查现有功能是否仍然正常工作。

3.提高软件质量：通过自动化测试，可以更早地发现和修复问题，从而提高软件的总体质量。

4.节省成本：虽然自动化测试需要一定的初期投入，但是长期来看，它可以减少因为错误和问题而产生的维护成本。

总的来说，前端自动化测试可以提高开发团队的效率，提高软件质量，减少错误，帮助团队更快地发布更高质量的产品。

# 接口自动化测试

除了传统用代码写测试用例外，市面上有很多产品可以直接进行接口测试如：

## postman

[https://www.postman.com/downloads/](https://www.postman.com/downloads/)

## PostmanCanary

[https://www.postman.com/downloads/canary/](https://www.postman.com/downloads/canary/)

## insomnia

[https://insomnia.rest/download/](https://insomnia.rest/download/)

## ApiPost

[https://www.apipost.cn/download.html](https://www.apipost.cn/download.html)

## eolink

[https://www.eolink.com/](https://www.eolink.com/)

## apifox

[https://www.apifox.cn/](https://www.apifox.cn/)


# 前端web自动化测试

实现Web自动化同样有很多工具，如模拟图形化操作的xdotool，常见Playwright、Puppeteer、selenium，或者DrissionPage：

# xdotool

参考这份笔记：[http://git.malu.me/xdotool自动化工具笔记/](http://git.malu.me/xdotool%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7%E7%AC%94%E8%AE%B0/)

# Playwright

Python版文档：[https://playwright.dev/python/docs/intro](https://playwright.dev/python/docs/intro)

Playwright 是一个开源的自动化测试工具，由 Microsoft 发布，专为测试现代 Web 应用而设计。它支持多种浏览器，包括 Chromium（Chrome 和 Edge）、Firefox 和 WebKit（Safari），使得跨浏览器测试变得简单。Playwright 允许开发者编写用于自动化浏览器操作的脚本，包括页面导航、元素选择、输入、文件上传下载等操作，以及捕捉网络活动、模拟移动设备、地理位置等高级功能。

Playwright 的主要特点包括：

1. **跨浏览器支持**：能够在所有主流浏览器上运行相同的测试脚本。
2. **无头模式和图形界面模式**：支持无头（headless）模式运行测试，这在 CI/CD 环境中非常有用，同时也支持有界面（headful）模式，方便开发时调试。
3. **快速准确**：通过等待元素可用而非固定时间等待，提高了测试的准确性和执行速度。
4. **现代 Web 功能支持**：支持最新的 Web 功能，包括但不限于网络存储、服务工作者、WebSockets 等。
5. **丰富的 API**：提供了一套丰富的 API，能够模拟几乎所有用户操作，并且能够处理复杂的 Web 应用场景。
6. **多语言绑定**：虽然 Playwright 本身是用 TypeScript/JavaScript 开发的，但它也提供了 Python、Java 和 C# 的绑定，使得非 JavaScript 开发者也能够轻松使用。

Playwright 适用于端到端的测试，包括功能测试、视觉回归测试和性能测试等。它通过提供一致的 API 来简化测试脚本的编写和维护工作，帮助开发者和测试工程师提高 Web 应用的质量和稳定性。

## 记录脚本

命令行界面CLI可用于记录用户交互并生成 Python 代码

```
playwright codegen malu.me
```

地址栏带多个传参解决办法：

```bat
set url="https://malu.me?aa=aa^^^&bb=bb^^^&cc=cc"
playwright codegen %url%
```

## 代码段

兄弟选择器，比如选择选择 text为“最近使用”的下面的兄弟div，可以使用布局选择器：[https://playwright.dev/python/docs/selectors#selecting-elements-based-on-layout](https://playwright.dev/python/docs/selectors#selecting-elements-based-on-layout)

    page.click('div:below(:text("最近使用"))')


# Puppeteer

puppeteer是谷歌chrome团队出的，支持chrome原生录制脚本，支持chrome无头模式，可模拟移动端，node编写，语法精炼，性能强劲。

API文档：https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md


## 原生录制

Recorder参考文档：[https://developer.chrome.com/docs/devtools/recorder/reference](https://developer.chrome.com/docs/devtools/recorder/reference)

## puppeteer 自动收取邮件示例：

	const puppeteer = require('puppeteer');
	
	// 注意该路径会和原始用户配置冲突，如果要用用户配置启动，请把开着的chrome先全部关闭
	const user_data_path = String.raw`${process.env.LocalAppData}\Google\Chrome\User Data`;
	const chrome_exe = String.raw`${process.env["ProgramFiles(x86)"]}\Google\Chrome\Application\chrome.exe`;
	
	const autoSubmitForm = async (url) => {
	    // 启动浏览器
	    const browser = await puppeteer.launch({
	        // 关闭无头模式，方便我们看到这个无头浏览器执行的过程
	        headless: false,
			// 取消加载默认配置
			// ignoreDefaultArgs: true,
	        // chrome 启动参数
	        args: ['--no-sandbox'],
	        // 显示chrome log信息和错误信息
	        dumpio: true,
			userDataDir: user_data_path,  // 浏览器用户路径（可选）
			executablePath: chrome_exe,  //调用浏览器位置（可选）
	    });
	
	    // 打开页面
	    const page = await browser.newPage();
	    // 设置浏览器视窗
	    page.setViewport({
	        width: 1920,
	        height: 1080,
	    });
	    // 地址栏输入网页地址
	    await page.goto(url, {
	        waitUntil: 'networkidle2', // 等待网络状态为空闲的时候才继续执行
	    });
	
	    // 点头像登录
	    await page.mouse.click(1300,441);
	    await page.waitFor(3000);
	    // 点代收邮箱
	    await page.mouse.click(80,376);
	    await page.waitFor(2000);
	    while (true) {
	        // 点收取
	        await page.mouse.click(265, 119);
	        await page.waitFor(60000*5);
	    }
	};
	
	if (require.main === module) {
	    autoSubmitForm('http://mail.qq.com/cgi-bin/frame_html');
	}

## puppeteer 中启用扩展

默认情况下puppeteer关闭了扩展，具体代码在 node_modules\puppeteer\lib\Launcher.js

	const DEFAULT_ARGS = [
	'--disable-background-networking',
	'--disable-background-timer-throttling',
	'--disable-breakpad',
	'--disable-client-side-phishing-detection',
	'--disable-default-apps',
	'--disable-dev-shm-usage',
	'--disable-extensions',
	....

我们可以在启动时关闭它：

	ignoreDefaultArgs: true,


# Selenium

Selenium 是一个用于 Web 自动化的开源工具。它可以用于自动化 Web 应用程序的测试、爬虫和其他操作。

Selenium 由两个主要部分组成：

* **Selenium WebDriver**：用于控制浏览器并与 Web 元素进行交互。
* **Selenium IDE**：一个用于记录和回放 Selenium 测试的集成开发环境。

Selenium 支持多种编程语言，包括 Python、Java、C#、JavaScript 等。

**使用 Python 使用 Selenium**

要使用 Python 使用 Selenium，您需要做的第一件事是安装 Selenium 库。您可以使用 pip 工具进行安装：

```
pip install selenium
```

安装 Selenium 库后，您就可以开始编写 Selenium 脚本了。

以下是一个简单的示例，用于打开首页并搜索“Selenium”：

```python
from selenium import webdriver

# 创建一个 WebDriver 实例
driver = webdriver.Chrome()

# 打开首页
driver.get("https://malu.me")

# 在搜索框中输入“Selenium”
search_box = driver.find_element_by_name("q")
search_box.send_keys("Selenium")

# 提交搜索
search_box.submit()

# 关闭浏览器
driver.quit()
```

**Selenium 的优势**

Selenium 具有以下优势：

* 开源且免费
* 支持多种编程语言
* 支持多种浏览器
* 易于使用
* 功能强大

**Selenium 的应用场景**

Selenium 可用于以下场景：

* Web 自动化测试
* Web 爬虫
* 自动化表单填写
* 自动化数据提取
* 自动化操作 Web 应用程序

Selenium 是一个强大的 Web 自动化工具。它可以用于自动化 Web 应用程序的测试、爬虫和其他操作。


# DrissionPage

## example:

```python
from DrissionPage import WebPage
from apscheduler.schedulers.blocking import BlockingScheduler  

page = WebPage('d')

# job1
def 每10分钟刷新页面():  
    # 每10分钟执行的任务
    page.get(zd.url["xx"]) # 此处刷新巡检页面
    print("每10分钟任务刷新页面,当前时间：",datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")[:-7]) 

# job2
def 提交巡检():
    page.ele('#j_id129').click() # 点击后出现巡检填报页面
    标题 =page.ele('#logEditForm:noteTitle2') # 根据ID找到
    巡检项1=page.ele('@name=answer_0')
    # 填充内容
    hour=time.localtime().tm_hour
    标题.input(str(hour)+'点巡检')
    
    巡检项1.input('ok',False) # False，是因为有时候里面会有默认的内容
   
    # 提交
    确定.click()
    print("当前时间：",datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")[:-7],str(hour)+'点巡检')  


scheduler = BlockingScheduler()  
 


# 添加任务  
scheduler.add_job(每10分钟刷新页面, 'interval', seconds=600)  
scheduler.add_job(提交巡检, 'cron',hour='0-7,18-23') 
# 启动调度器  
scheduler.start()  
  
# 程序将会一直阻塞在这里，直到手动停止调度器  
try:  
    while True:  
        time.sleep(2)  
except (KeyboardInterrupt, SystemExit):  
    # 如果程序收到中断信号（比如按下Ctrl+C），则停止调度器  
    scheduler.shutdown()
```



