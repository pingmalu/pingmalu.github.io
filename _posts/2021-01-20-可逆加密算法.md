---
layout: post
title: 可逆加密算法
---

对称可逆加密算法原理，我们可以把它简化为一道简单的数学题：

假设A有一个数字 88，接下来A想对它加密，拿一个密钥数7来加密，比如把它相加得到密文 88+7=95

A把加密后的95传输给B，B手上有协商好的密钥数7，同时也知道解密算法，那么B只要把密文减去密钥即可得到原来数字 95-7=88

以上传输过程中，只传递了密文95，原数字和密钥数都没被传输，也就实现了加密效果。

现实过程中，我们把这个数字看成计算机中的一个存储单位，比如字节（一个字节8比特），我们只要把这个字节做一遍数学运算，就能实现加密效果。

比如下面用PHP来实现对称加解密函数：

```php
/**
 * 加密函数
 * @param $data
 * @param $key
 * @return string
 */
public function encrypt($data, $key)
{
    $key = md5($key);
    $x = 0;
    $len = strlen($data);
    $l = strlen($key);

    $char = "";
    $str = "";
    // 循环拼接私钥md5后的字符，组装到待加密字串长度
    for ($i = 0; $i < $len; $i++) {
        if ($x == $l) {
            $x = 0;
        }
        $char .= $key[$x];
        $x++;
    }
    for ($i = 0; $i < $len; $i++) {
        // ord() 函数返回字符串的首个字符的 ASCII 值。
        // 给每个字符循环 加上 私钥md5后的 ASCII 与 256 求模后的值(求模是防止长度越界，比如中文字符)
        // 最后把 ASCII 值转成字符
        $str .= chr((ord($data[$i]) + ord($char[$i])) % 256);
    }
    return base64_encode($str); // 用基础的64个字符替换
}

/**
 * 解密函数
 * @param $data
 * @param $key
 * @return string
 */
public function decrypt($data, $key)
{
    $key = md5($key);
    $x = 0;
    $data = base64_decode($data);
    $len = strlen($data);
    $l = strlen($key);

    $char = "";
    $str = "";
    // 循环拼接私钥md5后的字符，组装到加密字串长度一样长
    for ($i = 0; $i < $len; $i++) {
        if ($x == $l) {
            $x = 0;
        }
        $char .= substr($key, $x, 1);
        $x++;
    }
    for ($i = 0; $i < $len; $i++) {
        if (ord(substr($data, $i, 1)) < ord(substr($char, $i, 1))) {
            // 如果加密字串ASCII小于密文ASCII，表示长度已越界，需要补256
            // 那么把 加密字串ASCII + 256 - 私钥md5后的字符串ASCII
            $str .= chr((ord(substr($data, $i, 1)) + 256) - ord(substr($char, $i, 1)));
        } else {
            $str .= chr(ord(substr($data, $i, 1)) - ord(substr($char, $i, 1)));
        }
    }
    return $str;
}
```








