---
layout: post
title: 分布式计算框架
---

# Ray

官方文档：[https://docs.ray.io/en/master/](https://docs.ray.io/en/master/)

## 快速安装

安装手册：[https://docs.ray.io/en/master/ray-overview/installation.html](https://docs.ray.io/en/master/ray-overview/installation.html)

## 集群部署

Head节点 (m1)：

    ray start --head --port=6333 --dashboard-host=0.0.0.0 --node-ip-address=10.147.19.20 --num-cpus=3 --num-gpus=1

Slave节点

  (bric)：

    ray start --address=10.147.19.20:6333 --node-ip-address=10.147.19.134 --num-cpus=3 --num-gpus=0

  (m4):

    ray start --address=10.147.19.20:6333 --node-ip-address=10.147.19.230 --num-cpus=8 --num-gpus=0


# 注意事项

1.ray 2.x版本与3.x版本不兼容，启动会报错，而且不同的python版本也不兼容！！！：

    RuntimeError: Version mismatch: The cluster was started with:
        Ray: 2.4.0
        Python: 3.8.10
    This process on node 10.147.19.20 was started with:
        Ray: 3.0.0.dev0
        Python: 3.8.10

2.遇到过一次WSL2下启动节点，但注册失败，检查环境日志无果，重启系统后成功。

可能是端口占用，或特定文件未被关闭。



# optuna

## 性能优化

optuna在分布式超参优化场景下，对Running状态的trial参数会用竞争策略，这将导致集群环境重复评估，严重浪费算力。

改造下采样函数，修复该问题：

```python
# 求最优超参数
def f(trial):
    # 定义要找的超参数,并设置上下限
    params = {
        'minima_size': trial.suggest_int('minima_size', args.minima_size_a, args.minima_size_b,step=minima_size_STEP),
    }

    print()
    t_list = trial.study.get_trials(states=[TrialState.COMPLETE,TrialState.RUNNING])
    n = trial._cached_frozen_trial
    for t in t_list:
        if n.number == t.number:
            continue
        if n.params == t.params:
            if 'HOST' in t.user_attrs and 'host' in t.user_attrs['HOST']:
                host_s = t.user_attrs['HOST']['host']
            else:
                host_s = ""
            HOST_dic = {"host": socket.gethostname(),"msg":None,"number": t.number, "HOST_s": host_s}
            if t.state == TrialState.RUNNING:
                HOST_dic["msg"] = "RUNNING"
                print("超参重复将跳过",t.params,HOST_dic)
                trial.set_user_attr("HOST", HOST_dic)
                raise optuna.TrialPruned
            else:
                HOST_dic["msg"] = "COMPLETE"
                print("超参重复将跳过",t.params,HOST_dic)
                trial.set_user_attr("HOST", HOST_dic)
                raise optuna.TrialPruned
    trial.set_user_attr("HOST", {"host": socket.gethostname()})

    args.opt_times += 1

    # 评估超参数
    return _c.params_test(args,params,MC)
```

## 网格搜索使用步进函数

网格搜索需要枚举，用步进函数替代它：

```python
def generate_float_list(start, end, step):
    """生成一个从 start 到 end 的列表，步长为 step。

    Args:
        start: 列表的起始值。
        end: 列表的结束值。
        step: 列表的步长。

    Returns:
        一个从 start 到 end 的列表，步长为 step。
    """

    list = []
    current = start
    while current <= end:
        list.append(current)
        current += step
    return list

search_space = {"minima_size":generate_float_list(args.minima_size_a, args.minima_size_b,step=minima_size_STEP)}

print("优化器:",study_name)

study = optuna.create_study(
    # sampler=TPESampler(seed=args.seedopt),
    sampler=GridSampler(search_space),
    study_name=study_name,
    direction='maximize',
    load_if_exists=True,
    storage=args.sqluri
    )
```




